package main

import (
	"bufio"
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/iancoleman/strcase"
	"golang.org/x/tools/imports"
	gofumpt "mvdan.cc/gofumpt/format"
)

var (
	inputFile         string
	cHeaderOutputFile string
	goOutputFile      string
	packageName       string
)

func init() {
	flag.StringVar(&inputFile, "i", "", "Remote url or local path of the protocol xml file")
	flag.StringVar(&cHeaderOutputFile, "cheader", "", "Path of the generated output c header file")
	flag.StringVar(&goOutputFile, "gosource", "", "Path of the generated output go file")
	flag.StringVar(&packageName, "pkg", "", "Go package name")
}

type Protocol struct {
	XMLName    xml.Name    `xml:"protocol"`
	Name       string      `xml:"name,attr"`
	Copyright  string      `xml:"copyright"`
	Interfaces []Interface `xml:"interface"`
}

type Interface struct {
	XMLName     xml.Name    `xml:"interface"`
	Name        string      `xml:"name,attr"`
	Description Description `xml:"description"`
	Requests    []Request   `xml:"request"`
	Events      []Event     `xml:"event"`
	Enums       []Enum      `xml:"enum"`
	Version     int         `xml:"version,attr"`
}

type Request struct {
	XMLName     xml.Name    `xml:"request"`
	Name        string      `xml:"name,attr"`
	Type        string      `xml:"type,attr"`
	Description Description `xml:"description"`
	Args        []Arg       `xml:"arg"`
	Since       int         `xml:"since,attr"`
}

type Event struct {
	XMLName     xml.Name    `xml:"event"`
	Name        string      `xml:"name,attr"`
	Type        string      `xml:"type,attr"`
	Description Description `xml:"description"`
	Args        []Arg       `xml:"arg"`
	Since       int         `xml:"since,attr"`
}

type Enum struct {
	XMLName     xml.Name    `xml:"enum"`
	Name        string      `xml:"name,attr"`
	Description Description `xml:"description"`
	Entries     []Entry     `xml:"entry"`
	Since       int         `xml:"since,attr"`
	Bitfield    bool        `xml:"bitfield,attr"`
}

type Entry struct {
	XMLName     xml.Name    `xml:"entry"`
	Name        string      `xml:"name,attr"`
	Value       string      `xml:"value,attr"`
	Summary     string      `xml:"summary,attr"`
	Description Description `xml:"description"`
	Since       int         `xml:"since,attr"`
}

type Arg struct {
	XMLName     xml.Name    `xml:"arg"`
	Name        string      `xml:"name,attr"`
	Type        string      `xml:"type,attr"`
	Summary     string      `xml:"summary,attr"`
	Interface   string      `xml:"interface,attr"`
	Enum        string      `xml:"enum,attr"`
	Description Description `xml:"description"`
	AllowNull   bool        `xml:"allow-null,attr"`
}

type Description struct {
	XMLName xml.Name `xml:"description"`
	Text    string   `xml:",chardata"`
	Summary string   `xml:"summary,attr"`
}

var protocol Protocol

func main() {
	flag.Parse()

	if inputFile == "" || cHeaderOutputFile == "" || goOutputFile == "" {
		flag.Usage()
		return
	}

	src, err := getInputFile(inputFile)
	if err != nil {
		log.Fatalf("unable to get input file: %v", err)
	}

	if err1 := xml.NewDecoder(src).Decode(&protocol); err1 != nil {
		log.Fatalf("unable to decode protocol xml: %v", err1)
	}
	if err2 := src.Close(); err2 != nil {
		log.Printf("unable to close input file: %v", err2)
	}

	emitCHeader()
	emitGoSource()
}

func emitCHeader() {
	f, err := os.Create(cHeaderOutputFile)
	if err != nil {
		log.Fatalf("unable to create output file: %v", err)
	}
	defer f.Close()

	fmt.Fprintf(f, "//go:build linux && !android\n\n")
	fmt.Fprintf(f, "// Code generated by internal/wayland/wl/gen; DO NOT EDIT.\n")
	fmt.Fprintf(f, "// XML file : %s\n\n", inputFile)
	fmt.Fprintf(f, "// %s Protocol Copyright:\n", protocol.Name)
	fmt.Fprint(f, comment(protocol.Copyright))

	fmt.Fprintf(f, "\n#ifndef %s\n", strcase.ToScreamingSnake(filepath.Base(cHeaderOutputFile)))
	fmt.Fprintf(f, "#define %s\n", strcase.ToScreamingSnake(filepath.Base(cHeaderOutputFile)))
	fmt.Fprintf(f, "#include \"wayland-util.h\"\n\n")

	fmt.Fprintf(f, "#ifdef  __cplusplus\n")
	fmt.Fprintf(f, "extern \"C\" {\n")
	fmt.Fprintf(f, "#endif\n\n")

	fmt.Fprintf(f, "struct wl_proxy;\n\n")
	fmt.Fprintf(f, "typedef int (*proc_wl_proxy_add_listener)(struct wl_proxy *proxy, void (**implementation)(void), void *data);\n")
	fmt.Fprintf(f, "typedef struct wl_proxy *(*proc_wl_proxy_marshal_flags)(struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface *interface, uint32_t version, uint32_t flags, ...);\n")
	fmt.Fprintf(f, "typedef uint32_t (*proc_wl_proxy_get_version)(struct wl_proxy *proxy);\n\n")

	{
		interfaces := map[string]struct{}{}
		for _, iface := range protocol.Interfaces {
			interfaces[iface.Name] = struct{}{}
			for _, event := range iface.Events {
				for _, arg := range event.Args {
					if arg.Interface != "" {
						interfaces[arg.Interface] = struct{}{}
					}
				}
			}
			for _, req := range iface.Requests {
				for _, arg := range req.Args {
					if arg.Interface != "" {
						interfaces[arg.Interface] = struct{}{}
					}
				}
			}
		}

		ifaces := []string{}
		for iface := range interfaces {
			ifaces = append(ifaces, iface)
		}
		sort.Slice(ifaces, func(i, j int) bool {
			return ifaces[i] < ifaces[j]
		})

		for _, iface := range ifaces {
			fmt.Fprintf(f, "struct %s;\n", iface)
		}
	}

	fmt.Fprintf(f, "\n")

	for _, iface := range protocol.Interfaces {
		fmt.Fprintf(f, "#ifndef %s_INTERFACE\n", strcase.ToScreamingSnake(iface.Name))
		fmt.Fprintf(f, "#define %s_INTERFACE\n", strcase.ToScreamingSnake(iface.Name))
		fmt.Fprintf(f, "extern const struct wl_interface %s_interface;\n", iface.Name)
		fmt.Fprintf(f, "#endif\n")
	}

	fmt.Fprintf(f, "\n")

	for _, iface := range protocol.Interfaces {
		if len(iface.Events) > 0 {

			fmt.Fprintf(f, "struct %s_listener {\n", iface.Name)
			for _, event := range iface.Events {
				args := []string{""}
				for _, arg := range event.Args {
					var argName string

					if (arg.Type == "object" || arg.Type == "new_id") && arg.Interface != "" {
						argName = "struct " + arg.Interface + " *" + arg.Name
					} else {
						typ := typeToCTypeMap[arg.Type]
						if strings.HasSuffix(typ, "*") {
							argName = typ + arg.Name
						} else {
							argName = typ + " " + arg.Name
						}
					}

					args = append(args, argName)
				}
				fmt.Fprintf(f, "	void (*%s)(void *data, struct %s *%s%s);\n", event.Name, iface.Name, iface.Name, strings.Join(args, ", "))
			}
			fmt.Fprintf(f, "};\n")

			fmt.Fprintf(f, "static inline int gamen_%s_add_listener(void *fp, struct %s *%s, const struct %s_listener *listener, void *data) {\n", iface.Name, iface.Name, iface.Name, iface.Name)
			fmt.Fprintf(f, "	return ((proc_wl_proxy_add_listener)fp)((struct wl_proxy *) %s, (void (**)(void)) listener, data);\n", iface.Name)
			fmt.Fprintf(f, "}\n\n")
		}

		for i, req := range iface.Requests {
			// emit special function for wl_registry.bind req
			if iface.Name == "wl_registry" && req.Name == "bind" {
				fmt.Fprintf(f, "static inline void *gamen_wl_registry_bind(void *fp, struct wl_registry *wl_registry, uint32_t name, const struct wl_interface *interface, uint32_t version) {\n")
				fmt.Fprintf(f, "	struct wl_proxy *id;\n")
				fmt.Fprintf(f, "	id = ((proc_wl_proxy_marshal_flags)fp)((struct wl_proxy *) wl_registry, %d, interface, version, 0, name, interface->name, version, NULL);\n", i)
				fmt.Fprintf(f, "	return (void *) id;\n")
				fmt.Fprintf(f, "}\n\n")
				continue
			}

			returnType := "void "
			args := []string{""}
			params := []string{""}

			var newIdArgName string
			var newIdInterface string

			for _, arg := range req.Args {
				var argName string

				if arg.Type == "new_id" && arg.Interface != "" {
					returnType = "struct " + arg.Interface + " *"
				} else if arg.Type == "new_id" && arg.Interface == "" {
					returnType = "void *"
				}

				if arg.Type == "new_id" {
					newIdArgName = arg.Name
					newIdInterface = arg.Interface
					continue
				}

				if arg.Type == "object" && arg.Interface != "" {
					argName = "struct " + arg.Interface + " *" + arg.Name
				} else {
					typ := typeToCTypeMap[arg.Type]
					if strings.HasSuffix(typ, "*") {
						argName = typ + arg.Name
					} else {
						argName = typ + " " + arg.Name
					}
				}

				args = append(args, argName)
				params = append(params, arg.Name)
			}

			destructorFlag := "0"
			if req.Type == "destructor" {
				destructorFlag = "1"
			}

			fmt.Fprintf(f, "static inline %sgamen_%s_%s(void *fp1, void *fp2, struct %s *%s%s) {\n", returnType, iface.Name, req.Name, iface.Name, iface.Name, strings.Join(args, ", "))
			if returnType != "void " {
				fmt.Fprintf(f, "	struct wl_proxy *%s;\n", newIdArgName)
				fmt.Fprintf(f, "	%s = ((proc_wl_proxy_marshal_flags)fp1)((struct wl_proxy *) %s, %d, &%s_interface, ((proc_wl_proxy_get_version)fp2)((struct wl_proxy *) %s), %s, NULL%s);\n", newIdArgName, iface.Name, i, newIdInterface, iface.Name, destructorFlag, strings.Join(params, ", "))
				fmt.Fprintf(f, "	return (struct %s *) %s;\n", newIdInterface, newIdArgName)
			} else {
				fmt.Fprintf(f, "	((proc_wl_proxy_marshal_flags)fp1)((struct wl_proxy *) %s, %d, NULL, ((proc_wl_proxy_get_version)fp2)((struct wl_proxy *) %s), %s%s);\n", iface.Name, i, iface.Name, destructorFlag, strings.Join(params, ", "))
			}
			fmt.Fprintf(f, "}\n\n")
		}
	}

	fmt.Fprintf(f, "\n#ifdef __cplusplus\n")
	fmt.Fprintf(f, "}\n")
	fmt.Fprintf(f, "#endif\n\n")

	fmt.Fprintf(f, "\n#endif\n")
}

func emitGoSource() {
	w := &bytes.Buffer{}
	// Header
	fmt.Fprintf(w, "// Code generated by internal/wayland/wl/gen; DO NOT EDIT.\n")
	fmt.Fprintf(w, "// XML file : %s\n\n", inputFile)
	fmt.Fprintf(w, "//go:build linux && !android\n\n")
	fmt.Fprintf(w, "package %s\n\n", packageName)

	fmt.Fprintf(w, "/*\n\n")
	fmt.Fprintf(w, "#include \"%s\"\n", filepath.Base(cHeaderOutputFile))
	fmt.Fprintf(w, "\n*/\n")
	fmt.Fprintf(w, "import \"C\"\n\n")

	for _, iface := range protocol.Interfaces {
		for _, enum := range iface.Enums {
			fmt.Fprint(w, comment(enum.Description.Text))
			fmt.Fprintf(w, "type enum_%s_%s C.uint32_t\n", iface.Name, enum.Name)
			fmt.Fprintf(w, "const (\n")
			for _, entry := range enum.Entries {
				fmt.Fprint(w, comment(entry.Summary))
				fmt.Fprintf(w, "	%s enum_%s_%s = %s\n", strcase.ToScreamingSnake(iface.Name+"_"+enum.Name+"_"+entry.Name), iface.Name, enum.Name, entry.Value)
			}
			fmt.Fprintf(w, ")\n")
		}

		if len(iface.Events) > 0 {
			fmt.Fprintf(w, "func (l *wl_library) %s_add_listener(%s *C.struct_%s, listener *C.struct_%s_listener, data unsafe.Pointer) C.int {\n", iface.Name, iface.Name, iface.Name, iface.Name)
			fmt.Fprintf(w, "	return C.gamen_%s_add_listener(l.wl_proxy_add_listener_handle, %s, listener, data)\n", iface.Name, iface.Name)
			fmt.Fprintf(w, "}\n")
		}

		for _, req := range iface.Requests {
			if iface.Name == "wl_registry" && req.Name == "bind" {
				fmt.Fprint(w, comment(req.Description.Summary))
				fmt.Fprint(w, comment(req.Description.Text))
				fmt.Fprintf(w, "func (l *wl_library) wl_registry_bind(wl_registry *C.struct_wl_registry, name C.uint32_t, iface *C.struct_wl_interface, version C.uint32_t) unsafe.Pointer {\n")
				fmt.Fprintf(w, "	return C.gamen_wl_registry_bind(l.wl_proxy_marshal_flags, wl_registry, name,iface,version)\n")
				fmt.Fprintf(w, "}\n")
				continue
			}

			var returnType string
			args := []string{""}
			params := []string{""}

			for _, arg := range req.Args {
				if arg.Type == "new_id" {
					returnType = "*C.struct_" + arg.Interface
					continue
				}

				var argName string
				param := arg.Name

				if arg.Type == "object" && arg.Interface != "" {
					argName = arg.Name + " *C.struct_" + arg.Interface
				} else if arg.Enum != "" {
					split := strings.Split(arg.Enum, ".")
					if len(split) == 1 {
						argName = fmt.Sprintf("%s enum_%s_%s", arg.Name, iface.Name, arg.Enum)
					} else {
						argName = fmt.Sprintf("%s enum_%s", arg.Name, strings.Join(split, "_"))
					}
					param = fmt.Sprintf("%s(%s)", typeToCGOTypeMap[arg.Type], arg.Name)
				} else {
					argName = arg.Name + " " + typeToCGOTypeMap[arg.Type]
				}

				args = append(args, argName)
				params = append(params, param)
			}

			fmt.Fprint(w, comment(req.Description.Summary))
			fmt.Fprint(w, comment(req.Description.Text))
			fmt.Fprintf(w, "func (l *wl_library) %s_%s(%s *C.struct_%s%s) %s {\n", iface.Name, req.Name, iface.Name, iface.Name, strings.Join(args, ", "), returnType)
			if returnType != "" {
				fmt.Fprintf(w, "	return C.gamen_%s_%s(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, %s%s)\n", iface.Name, req.Name, iface.Name, strings.Join(params, ", "))
			} else {
				fmt.Fprintf(w, "	C.gamen_%s_%s(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, %s%s)\n", iface.Name, req.Name, iface.Name, strings.Join(params, ", "))
			}
			fmt.Fprintf(w, "}\n")
		}

		if iface.Name != "wl_display" && !hasDestroy(iface) {
			fmt.Fprintf(w, "func (l *wl_library) %s_destroy(%s *C.struct_%s) {\n", iface.Name, iface.Name, iface.Name)
			fmt.Fprintf(w, "	l.wl_proxy_destroy((*C.struct_wl_proxy)(%s))\n", iface.Name)
			fmt.Fprintf(w, "}\n")
		}
	}

	dst, err := os.Create(goOutputFile)
	if err != nil {
		log.Fatalf("unable to create output file: %v", err)
	}

	if _, err := dst.Write(fmtFile(w.Bytes())); err != nil {
		log.Fatalf("unable to copy to output file: %v", err)
	}

	if err := dst.Close(); err != nil {
		log.Fatalf("unable to close to output file: %v", err)
	}
}

var typeToCTypeMap map[string]string = map[string]string{
	"int":    "int32_t",
	"uint":   "uint32_t",
	"fixed":  "wl_fixed_t",
	"string": "const char *",
	"object": "void *",
	"array":  "struct wl_array *",
	"fd":     "int32_t",
}

var typeToCGOTypeMap map[string]string = map[string]string{
	"int":    "C.int32_t",
	"uint":   "C.uint32_t",
	"fixed":  "C.wl_fixed_t",
	"string": "*C.char",
	"object": "unsafe.Pointer",
	"array":  "*C.struct_wl_array",
	"fd":     "C.int32_t",
}

func getInputFile(file string) (io.ReadCloser, error) {
	if strings.HasPrefix(file, "http") {
		resp, err := http.Get(file)
		if err != nil {
			return nil, err
		}

		return resp.Body, nil
	}

	return os.Open(file)
}

func fmtFile(b []byte) []byte {
	// Run goimports
	b, err := imports.Process("", b, nil)
	if err != nil {
		log.Fatalf("cannot run goimports on file: %v", err)
	}

	langVersion := ""
	out, err := exec.Command("go", "list", "-m", "-f", "{{.GoVersion}}").Output()
	outSlice := bytes.Split(out, []byte("\n"))
	out = outSlice[0]
	out = bytes.TrimSpace(out)
	if err == nil && len(out) > 0 {
		langVersion = string(out)
	}

	// Run gofumpt
	b, err = gofumpt.Source(b, gofumpt.Options{LangVersion: langVersion, ExtraRules: true})
	if err != nil {
		log.Fatalf("cannot run gofumpt on file: %v", err)
	}

	return b
}

func comment(s string) string {
	sb := strings.Builder{}

	scanner := bufio.NewScanner(strings.NewReader(s))
	for scanner.Scan() {
		sb.WriteString("// ")
		sb.WriteString(strings.TrimSpace(scanner.Text()))
		sb.WriteString("\n")
	}

	return strings.TrimSuffix(sb.String(), "// \n")
}

func hasDestroy(v Interface) bool {
	for _, r := range v.Requests {
		if r.Name == "destroy" {
			return true
		}
	}

	return false
}
