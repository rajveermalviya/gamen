// Code generated by internal/wayland/wl/gen; DO NOT EDIT.
// XML file : ./protocols/wayland.xml

//go:build linux && !android

package wayland

/*

#include "wayland-client-protocol.h"

*/
import "C"
import "unsafe"

// These errors are global and can be emitted in response to any
// server request.
type wl_display_error C.uint32_t

const (
	// server couldn't find object
	WL_DISPLAY_ERROR_INVALID_OBJECT wl_display_error = 0
	// method doesn't exist on the specified interface or malformed request
	WL_DISPLAY_ERROR_INVALID_METHOD wl_display_error = 1
	// server is out of memory
	WL_DISPLAY_ERROR_NO_MEMORY wl_display_error = 2
	// implementation error in compositor
	WL_DISPLAY_ERROR_IMPLEMENTATION wl_display_error = 3
)

func (l *wl_library) wl_display_add_listener(wl_display *C.struct_wl_display, listener *C.struct_wl_display_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_display_add_listener(l.wl_proxy_add_listener_handle, wl_display, listener, data)
}

// asynchronous roundtrip
//
// The sync request asks the server to emit the 'done' event
// on the returned wl_callback object.  Since requests are
// handled in-order and events are delivered in-order, this can
// be used as a barrier to ensure all previous requests and the
// resulting events have been handled.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the event serial.
func (l *wl_library) wl_display_sync(wl_display *C.struct_wl_display) *C.struct_wl_callback {
	return C.gamen_wl_display_sync(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_display)
}

// get global registry object
//
// This request creates a registry object that allows the client
// to list and bind the global objects available from the
// compositor.
//
// It should be noted that the server side resources consumed in
// response to a get_registry request can only be released when the
// client disconnects, not when the client side proxy is destroyed.
// Therefore, clients should invoke get_registry as infrequently as
// possible to avoid wasting memory.
func (l *wl_library) wl_display_get_registry(wl_display *C.struct_wl_display) *C.struct_wl_registry {
	return C.gamen_wl_display_get_registry(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_display)
}

func (l *wl_library) wl_registry_add_listener(wl_registry *C.struct_wl_registry, listener *C.struct_wl_registry_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_registry_add_listener(l.wl_proxy_add_listener_handle, wl_registry, listener, data)
}

// bind an object to the display
//
// Binds a new, client-created object to the server using the
// specified name as the identifier.
func (l *wl_library) wl_registry_bind(wl_registry *C.struct_wl_registry, name C.uint32_t, iface *C.struct_wl_interface, version C.uint32_t) unsafe.Pointer {
	return C.gamen_wl_registry_bind(l.wl_proxy_marshal_flags, wl_registry, name, iface, version)
}

func (l *wl_library) wl_registry_destroy(wl_registry *C.struct_wl_registry) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_registry))
}

func (l *wl_library) wl_callback_add_listener(wl_callback *C.struct_wl_callback, listener *C.struct_wl_callback_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_callback_add_listener(l.wl_proxy_add_listener_handle, wl_callback, listener, data)
}

func (l *wl_library) wl_callback_destroy(wl_callback *C.struct_wl_callback) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_callback))
}

// create new surface
//
// Ask the compositor to create a new surface.
func (l *wl_library) wl_compositor_create_surface(wl_compositor *C.struct_wl_compositor) *C.struct_wl_surface {
	return C.gamen_wl_compositor_create_surface(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_compositor)
}

// create new region
//
// Ask the compositor to create a new region.
func (l *wl_library) wl_compositor_create_region(wl_compositor *C.struct_wl_compositor) *C.struct_wl_region {
	return C.gamen_wl_compositor_create_region(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_compositor)
}

func (l *wl_library) wl_compositor_destroy(wl_compositor *C.struct_wl_compositor) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_compositor))
}

// create a buffer from the pool
//
// Create a wl_buffer object from the pool.
//
// The buffer is created offset bytes into the pool and has
// width and height as specified.  The stride argument specifies
// the number of bytes from the beginning of one row to the beginning
// of the next.  The format is the pixel format of the buffer and
// must be one of those advertised through the wl_shm.format event.
//
// A buffer will keep a reference to the pool it was created from
// so it is valid to destroy the pool immediately after creating
// a buffer from it.
func (l *wl_library) wl_shm_pool_create_buffer(wl_shm_pool *C.struct_wl_shm_pool, offset, width, height, stride C.int32_t, format C.uint32_t) *C.struct_wl_buffer {
	return C.gamen_wl_shm_pool_create_buffer(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shm_pool, offset, width, height, stride, format)
}

// destroy the pool
//
// Destroy the shared memory pool.
//
// The mmapped memory will be released when all
// buffers that have been created from this pool
// are gone.
func (l *wl_library) wl_shm_pool_destroy(wl_shm_pool *C.struct_wl_shm_pool) {
	C.gamen_wl_shm_pool_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shm_pool)
}

// change the size of the pool mapping
//
// This request will cause the server to remap the backing memory
// for the pool from the file descriptor passed when the pool was
// created, but using the new size.  This request can only be
// used to make the pool bigger.
//
// This request only changes the amount of bytes that are mmapped
// by the server and does not touch the file corresponding to the
// file descriptor passed at creation time. It is the client's
// responsibility to ensure that the file is at least as big as
// the new pool size.
func (l *wl_library) wl_shm_pool_resize(wl_shm_pool *C.struct_wl_shm_pool, size C.int32_t) {
	C.gamen_wl_shm_pool_resize(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shm_pool, size)
}

// These errors can be emitted in response to wl_shm requests.
type wl_shm_error C.uint32_t

const (
	// buffer format is not known
	WL_SHM_ERROR_INVALID_FORMAT wl_shm_error = 0
	// invalid size or stride during pool or buffer creation
	WL_SHM_ERROR_INVALID_STRIDE wl_shm_error = 1
	// mmapping the file descriptor failed
	WL_SHM_ERROR_INVALID_FD wl_shm_error = 2
)

// This describes the memory layout of an individual pixel.
//
// All renderers should support argb8888 and xrgb8888 but any other
// formats are optional and may not be supported by the particular
// renderer in use.
//
// The drm format codes match the macros defined in drm_fourcc.h, except
// argb8888 and xrgb8888. The formats actually supported by the compositor
// will be reported by the format event.
//
// For all wl_shm formats and unless specified in another protocol
// extension, pre-multiplied alpha is used for pixel values.
type wl_shm_format C.uint32_t

const (
	// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	WL_SHM_FORMAT_ARGB_8888 wl_shm_format = 0
	// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	WL_SHM_FORMAT_XRGB_8888 wl_shm_format = 1
	// 8-bit color index format, [7:0] C
	WL_SHM_FORMAT_C_8 wl_shm_format = 0x20203843
	// 8-bit RGB format, [7:0] R:G:B 3:3:2
	WL_SHM_FORMAT_RGB_332 wl_shm_format = 0x38424752
	// 8-bit BGR format, [7:0] B:G:R 2:3:3
	WL_SHM_FORMAT_BGR_233 wl_shm_format = 0x38524742
	// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	WL_SHM_FORMAT_XRGB_4444 wl_shm_format = 0x32315258
	// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	WL_SHM_FORMAT_XBGR_4444 wl_shm_format = 0x32314258
	// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	WL_SHM_FORMAT_RGBX_4444 wl_shm_format = 0x32315852
	// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	WL_SHM_FORMAT_BGRX_4444 wl_shm_format = 0x32315842
	// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	WL_SHM_FORMAT_ARGB_4444 wl_shm_format = 0x32315241
	// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	WL_SHM_FORMAT_ABGR_4444 wl_shm_format = 0x32314241
	// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	WL_SHM_FORMAT_RGBA_4444 wl_shm_format = 0x32314152
	// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	WL_SHM_FORMAT_BGRA_4444 wl_shm_format = 0x32314142
	// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	WL_SHM_FORMAT_XRGB_1555 wl_shm_format = 0x35315258
	// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	WL_SHM_FORMAT_XBGR_1555 wl_shm_format = 0x35314258
	// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	WL_SHM_FORMAT_RGBX_5551 wl_shm_format = 0x35315852
	// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	WL_SHM_FORMAT_BGRX_5551 wl_shm_format = 0x35315842
	// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	WL_SHM_FORMAT_ARGB_1555 wl_shm_format = 0x35315241
	// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	WL_SHM_FORMAT_ABGR_1555 wl_shm_format = 0x35314241
	// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	WL_SHM_FORMAT_RGBA_5551 wl_shm_format = 0x35314152
	// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	WL_SHM_FORMAT_BGRA_5551 wl_shm_format = 0x35314142
	// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	WL_SHM_FORMAT_RGB_565 wl_shm_format = 0x36314752
	// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	WL_SHM_FORMAT_BGR_565 wl_shm_format = 0x36314742
	// 24-bit RGB format, [23:0] R:G:B little endian
	WL_SHM_FORMAT_RGB_888 wl_shm_format = 0x34324752
	// 24-bit BGR format, [23:0] B:G:R little endian
	WL_SHM_FORMAT_BGR_888 wl_shm_format = 0x34324742
	// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	WL_SHM_FORMAT_XBGR_8888 wl_shm_format = 0x34324258
	// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	WL_SHM_FORMAT_RGBX_8888 wl_shm_format = 0x34325852
	// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	WL_SHM_FORMAT_BGRX_8888 wl_shm_format = 0x34325842
	// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	WL_SHM_FORMAT_ABGR_8888 wl_shm_format = 0x34324241
	// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	WL_SHM_FORMAT_RGBA_8888 wl_shm_format = 0x34324152
	// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	WL_SHM_FORMAT_BGRA_8888 wl_shm_format = 0x34324142
	// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	WL_SHM_FORMAT_XRGB_2101010 wl_shm_format = 0x30335258
	// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	WL_SHM_FORMAT_XBGR_2101010 wl_shm_format = 0x30334258
	// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	WL_SHM_FORMAT_RGBX_1010102 wl_shm_format = 0x30335852
	// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	WL_SHM_FORMAT_BGRX_1010102 wl_shm_format = 0x30335842
	// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	WL_SHM_FORMAT_ARGB_2101010 wl_shm_format = 0x30335241
	// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	WL_SHM_FORMAT_ABGR_2101010 wl_shm_format = 0x30334241
	// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	WL_SHM_FORMAT_RGBA_1010102 wl_shm_format = 0x30334152
	// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	WL_SHM_FORMAT_BGRA_1010102 wl_shm_format = 0x30334142
	// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	WL_SHM_FORMAT_YUYV wl_shm_format = 0x56595559
	// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	WL_SHM_FORMAT_YVYU wl_shm_format = 0x55595659
	// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	WL_SHM_FORMAT_UYVY wl_shm_format = 0x59565955
	// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	WL_SHM_FORMAT_VYUY wl_shm_format = 0x59555956
	// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	WL_SHM_FORMAT_AYUV wl_shm_format = 0x56555941
	// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	WL_SHM_FORMAT_NV_12 wl_shm_format = 0x3231564e
	// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	WL_SHM_FORMAT_NV_21 wl_shm_format = 0x3132564e
	// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	WL_SHM_FORMAT_NV_16 wl_shm_format = 0x3631564e
	// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	WL_SHM_FORMAT_NV_61 wl_shm_format = 0x3136564e
	// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	WL_SHM_FORMAT_YUV_410 wl_shm_format = 0x39565559
	// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	WL_SHM_FORMAT_YVU_410 wl_shm_format = 0x39555659
	// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	WL_SHM_FORMAT_YUV_411 wl_shm_format = 0x31315559
	// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	WL_SHM_FORMAT_YVU_411 wl_shm_format = 0x31315659
	// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	WL_SHM_FORMAT_YUV_420 wl_shm_format = 0x32315559
	// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	WL_SHM_FORMAT_YVU_420 wl_shm_format = 0x32315659
	// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	WL_SHM_FORMAT_YUV_422 wl_shm_format = 0x36315559
	// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	WL_SHM_FORMAT_YVU_422 wl_shm_format = 0x36315659
	// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	WL_SHM_FORMAT_YUV_444 wl_shm_format = 0x34325559
	// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	WL_SHM_FORMAT_YVU_444 wl_shm_format = 0x34325659
	// [7:0] R
	WL_SHM_FORMAT_R_8 wl_shm_format = 0x20203852
	// [15:0] R little endian
	WL_SHM_FORMAT_R_16 wl_shm_format = 0x20363152
	// [15:0] R:G 8:8 little endian
	WL_SHM_FORMAT_RG_88 wl_shm_format = 0x38384752
	// [15:0] G:R 8:8 little endian
	WL_SHM_FORMAT_GR_88 wl_shm_format = 0x38385247
	// [31:0] R:G 16:16 little endian
	WL_SHM_FORMAT_RG_1616 wl_shm_format = 0x32334752
	// [31:0] G:R 16:16 little endian
	WL_SHM_FORMAT_GR_1616 wl_shm_format = 0x32335247
	// [63:0] x:R:G:B 16:16:16:16 little endian
	WL_SHM_FORMAT_XRGB_16161616_F wl_shm_format = 0x48345258
	// [63:0] x:B:G:R 16:16:16:16 little endian
	WL_SHM_FORMAT_XBGR_16161616_F wl_shm_format = 0x48344258
	// [63:0] A:R:G:B 16:16:16:16 little endian
	WL_SHM_FORMAT_ARGB_16161616_F wl_shm_format = 0x48345241
	// [63:0] A:B:G:R 16:16:16:16 little endian
	WL_SHM_FORMAT_ABGR_16161616_F wl_shm_format = 0x48344241
	// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	WL_SHM_FORMAT_XYUV_8888 wl_shm_format = 0x56555958
	// [23:0] Cr:Cb:Y 8:8:8 little endian
	WL_SHM_FORMAT_VUY_888 wl_shm_format = 0x34325556
	// Y followed by U then V, 10:10:10. Non-linear modifier only
	WL_SHM_FORMAT_VUY_101010 wl_shm_format = 0x30335556
	// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	WL_SHM_FORMAT_Y_210 wl_shm_format = 0x30313259
	// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	WL_SHM_FORMAT_Y_212 wl_shm_format = 0x32313259
	// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	WL_SHM_FORMAT_Y_216 wl_shm_format = 0x36313259
	// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	WL_SHM_FORMAT_Y_410 wl_shm_format = 0x30313459
	// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WL_SHM_FORMAT_Y_412 wl_shm_format = 0x32313459
	// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	WL_SHM_FORMAT_Y_416 wl_shm_format = 0x36313459
	// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	WL_SHM_FORMAT_XVYU_2101010 wl_shm_format = 0x30335658
	// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WL_SHM_FORMAT_XVYU_12_16161616 wl_shm_format = 0x36335658
	// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	WL_SHM_FORMAT_XVYU_16161616 wl_shm_format = 0x38345658
	// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WL_SHM_FORMAT_Y_0_L_0 wl_shm_format = 0x304c3059
	// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WL_SHM_FORMAT_X_0_L_0 wl_shm_format = 0x304c3058
	// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	WL_SHM_FORMAT_Y_0_L_2 wl_shm_format = 0x324c3059
	// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	WL_SHM_FORMAT_X_0_L_2        wl_shm_format = 0x324c3058
	WL_SHM_FORMAT_YUV_420_8_BIT  wl_shm_format = 0x38305559
	WL_SHM_FORMAT_YUV_420_10_BIT wl_shm_format = 0x30315559
	WL_SHM_FORMAT_XRGB_8888_A_8  wl_shm_format = 0x38415258
	WL_SHM_FORMAT_XBGR_8888_A_8  wl_shm_format = 0x38414258
	WL_SHM_FORMAT_RGBX_8888_A_8  wl_shm_format = 0x38415852
	WL_SHM_FORMAT_BGRX_8888_A_8  wl_shm_format = 0x38415842
	WL_SHM_FORMAT_RGB_888_A_8    wl_shm_format = 0x38413852
	WL_SHM_FORMAT_BGR_888_A_8    wl_shm_format = 0x38413842
	WL_SHM_FORMAT_RGB_565_A_8    wl_shm_format = 0x38413552
	WL_SHM_FORMAT_BGR_565_A_8    wl_shm_format = 0x38413542
	// non-subsampled Cr:Cb plane
	WL_SHM_FORMAT_NV_24 wl_shm_format = 0x3432564e
	// non-subsampled Cb:Cr plane
	WL_SHM_FORMAT_NV_42 wl_shm_format = 0x3234564e
	// 2x1 subsampled Cr:Cb plane, 10 bit per channel
	WL_SHM_FORMAT_P_210 wl_shm_format = 0x30313250
	// 2x2 subsampled Cr:Cb plane 10 bits per channel
	WL_SHM_FORMAT_P_010 wl_shm_format = 0x30313050
	// 2x2 subsampled Cr:Cb plane 12 bits per channel
	WL_SHM_FORMAT_P_012 wl_shm_format = 0x32313050
	// 2x2 subsampled Cr:Cb plane 16 bits per channel
	WL_SHM_FORMAT_P_016 wl_shm_format = 0x36313050
	// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	WL_SHM_FORMAT_AXBXGXRX_106106106106 wl_shm_format = 0x30314241
	// 2x2 subsampled Cr:Cb plane
	WL_SHM_FORMAT_NV_15 wl_shm_format = 0x3531564e
	WL_SHM_FORMAT_Q_410 wl_shm_format = 0x30313451
	WL_SHM_FORMAT_Q_401 wl_shm_format = 0x31303451
	// [63:0] x:R:G:B 16:16:16:16 little endian
	WL_SHM_FORMAT_XRGB_16161616 wl_shm_format = 0x38345258
	// [63:0] x:B:G:R 16:16:16:16 little endian
	WL_SHM_FORMAT_XBGR_16161616 wl_shm_format = 0x38344258
	// [63:0] A:R:G:B 16:16:16:16 little endian
	WL_SHM_FORMAT_ARGB_16161616 wl_shm_format = 0x38345241
	// [63:0] A:B:G:R 16:16:16:16 little endian
	WL_SHM_FORMAT_ABGR_16161616 wl_shm_format = 0x38344241
)

func (l *wl_library) wl_shm_add_listener(wl_shm *C.struct_wl_shm, listener *C.struct_wl_shm_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_shm_add_listener(l.wl_proxy_add_listener_handle, wl_shm, listener, data)
}

// create a shm pool
//
// Create a new wl_shm_pool object.
//
// The pool can be used to create shared memory based buffer
// objects.  The server will mmap size bytes of the passed file
// descriptor, to use as backing memory for the pool.
func (l *wl_library) wl_shm_create_pool(wl_shm *C.struct_wl_shm, fd, size C.int32_t) *C.struct_wl_shm_pool {
	return C.gamen_wl_shm_create_pool(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shm, fd, size)
}

func (l *wl_library) wl_shm_destroy(wl_shm *C.struct_wl_shm) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_shm))
}

func (l *wl_library) wl_buffer_add_listener(wl_buffer *C.struct_wl_buffer, listener *C.struct_wl_buffer_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_buffer_add_listener(l.wl_proxy_add_listener_handle, wl_buffer, listener, data)
}

// destroy a buffer
//
// Destroy a buffer. If and how you need to release the backing
// storage is defined by the buffer factory interface.
//
// For possible side-effects to a surface, see wl_surface.attach.
func (l *wl_library) wl_buffer_destroy(wl_buffer *C.struct_wl_buffer) {
	C.gamen_wl_buffer_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_buffer)
}

type wl_data_offer_error C.uint32_t

const (
	// finish request was called untimely
	WL_DATA_OFFER_ERROR_INVALID_FINISH wl_data_offer_error = 0
	// action mask contains invalid values
	WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK wl_data_offer_error = 1
	// action argument has an invalid value
	WL_DATA_OFFER_ERROR_INVALID_ACTION wl_data_offer_error = 2
	// offer doesn't accept this request
	WL_DATA_OFFER_ERROR_INVALID_OFFER wl_data_offer_error = 3
)

func (l *wl_library) wl_data_offer_add_listener(wl_data_offer *C.struct_wl_data_offer, listener *C.struct_wl_data_offer_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_data_offer_add_listener(l.wl_proxy_add_listener_handle, wl_data_offer, listener, data)
}

// accept one of the offered mime types
//
// Indicate that the client can accept the given mime type, or
// NULL for not accepted.
//
// For objects of version 2 or older, this request is used by the
// client to give feedback whether the client can receive the given
// mime type, or NULL if none is accepted; the feedback does not
// determine whether the drag-and-drop operation succeeds or not.
//
// For objects of version 3 or newer, this request determines the
// final result of the drag-and-drop operation. If the end result
// is that no mime types were accepted, the drag-and-drop operation
// will be cancelled and the corresponding drag source will receive
// wl_data_source.cancelled. Clients may still use this event in
// conjunction with wl_data_source.action for feedback.
func (l *wl_library) wl_data_offer_accept(wl_data_offer *C.struct_wl_data_offer, serial C.uint32_t, mime_type *C.char) {
	C.gamen_wl_data_offer_accept(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_offer, serial, mime_type)
}

// request that the data is transferred
//
// To transfer the offered data, the client issues this request
// and indicates the mime type it wants to receive.  The transfer
// happens through the passed file descriptor (typically created
// with the pipe system call).  The source client writes the data
// in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until
// EOF and then closes its end, at which point the transfer is
// complete.
//
// This request may happen multiple times for different mime types,
// both before and after wl_data_device.drop. Drag-and-drop destination
// clients may preemptively fetch data or examine it more closely to
// determine acceptance.
func (l *wl_library) wl_data_offer_receive(wl_data_offer *C.struct_wl_data_offer, mime_type *C.char, fd C.int32_t) {
	C.gamen_wl_data_offer_receive(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_offer, mime_type, fd)
}

// destroy data offer
//
// Destroy the data offer.
func (l *wl_library) wl_data_offer_destroy(wl_data_offer *C.struct_wl_data_offer) {
	C.gamen_wl_data_offer_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_offer)
}

// the offer will no longer be used
//
// Notifies the compositor that the drag destination successfully
// finished the drag-and-drop operation.
//
// Upon receiving this request, the compositor will emit
// wl_data_source.dnd_finished on the drag source client.
//
// It is a client error to perform other requests than
// wl_data_offer.destroy after this one. It is also an error to perform
// this request after a NULL mime type has been set in
// wl_data_offer.accept or no action was received through
// wl_data_offer.action.
//
// If wl_data_offer.finish request is received for a non drag and drop
// operation, the invalid_finish protocol error is raised.
func (l *wl_library) wl_data_offer_finish(wl_data_offer *C.struct_wl_data_offer) {
	C.gamen_wl_data_offer_finish(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_offer)
}

// set the available/preferred drag-and-drop actions
//
// Sets the actions that the destination side client supports for
// this operation. This request may trigger the emission of
// wl_data_source.action and wl_data_offer.action events if the compositor
// needs to change the selected action.
//
// This request can be called multiple times throughout the
// drag-and-drop operation, typically in response to wl_data_device.enter
// or wl_data_device.motion events.
//
// This request determines the final result of the drag-and-drop
// operation. If the end result is that no action is accepted,
// the drag source will receive wl_data_source.cancelled.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, and the preferred_action
// argument must only contain one of those values set, otherwise it
// will result in a protocol error.
//
// While managing an "ask" action, the destination drag-and-drop client
// may perform further wl_data_offer.receive requests, and is expected
// to perform one last wl_data_offer.set_actions request with a preferred
// action other than "ask" (and optionally wl_data_offer.accept) before
// requesting wl_data_offer.finish, in order to convey the action selected
// by the user. If the preferred action is not in the
// wl_data_offer.source_actions mask, an error will be raised.
//
// If the "ask" action is dismissed (e.g. user cancellation), the client
// is expected to perform wl_data_offer.destroy right away.
//
// This request can only be made on drag-and-drop offers, a protocol error
// will be raised otherwise.
func (l *wl_library) wl_data_offer_set_actions(wl_data_offer *C.struct_wl_data_offer, dnd_actions, preferred_action C.uint32_t) {
	C.gamen_wl_data_offer_set_actions(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_offer, dnd_actions, preferred_action)
}

type wl_data_source_error C.uint32_t

const (
	// action mask contains invalid values
	WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK wl_data_source_error = 0
	// source doesn't accept this request
	WL_DATA_SOURCE_ERROR_INVALID_SOURCE wl_data_source_error = 1
)

func (l *wl_library) wl_data_source_add_listener(wl_data_source *C.struct_wl_data_source, listener *C.struct_wl_data_source_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_data_source_add_listener(l.wl_proxy_add_listener_handle, wl_data_source, listener, data)
}

// add an offered mime type
//
// This request adds a mime type to the set of mime types
// advertised to targets.  Can be called several times to offer
// multiple types.
func (l *wl_library) wl_data_source_offer(wl_data_source *C.struct_wl_data_source, mime_type *C.char) {
	C.gamen_wl_data_source_offer(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_source, mime_type)
}

// destroy the data source
//
// Destroy the data source.
func (l *wl_library) wl_data_source_destroy(wl_data_source *C.struct_wl_data_source) {
	C.gamen_wl_data_source_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_source)
}

// set the available drag-and-drop actions
//
// Sets the actions that the source side client supports for this
// operation. This request may trigger wl_data_source.action and
// wl_data_offer.action events if the compositor needs to change the
// selected action.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, otherwise it will result
// in a protocol error.
//
// This request must be made once only, and can only be made on sources
// used in drag-and-drop, so it must be performed before
// wl_data_device.start_drag. Attempting to use the source other than
// for drag-and-drop will raise a protocol error.
func (l *wl_library) wl_data_source_set_actions(wl_data_source *C.struct_wl_data_source, dnd_actions C.uint32_t) {
	C.gamen_wl_data_source_set_actions(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_source, dnd_actions)
}

type wl_data_device_error C.uint32_t

const (
	// given wl_surface has another role
	WL_DATA_DEVICE_ERROR_ROLE wl_data_device_error = 0
)

func (l *wl_library) wl_data_device_add_listener(wl_data_device *C.struct_wl_data_device, listener *C.struct_wl_data_device_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_data_device_add_listener(l.wl_proxy_add_listener_handle, wl_data_device, listener, data)
}

// start drag-and-drop operation
//
// This request asks the compositor to start a drag-and-drop
// operation on behalf of the client.
//
// The source argument is the data source that provides the data
// for the eventual data transfer. If source is NULL, enter, leave
// and motion events are sent only to the client that initiated the
// drag and the client is expected to handle the data passing
// internally. If source is destroyed, the drag-and-drop session will be
// cancelled.
//
// The origin surface is the surface where the drag originates and
// the client must have an active implicit grab that matches the
// serial.
//
// The icon surface is an optional (can be NULL) surface that
// provides an icon to be moved around with the cursor.  Initially,
// the top-left corner of the icon surface is placed at the cursor
// hotspot, but subsequent wl_surface.attach request can move the
// relative position. Attach requests must be confirmed with
// wl_surface.commit as usual. The icon surface is given the role of
// a drag-and-drop icon. If the icon surface already has another role,
// it raises a protocol error.
//
// The current and pending input regions of the icon wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the icon surface. When the use
// as an icon ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
func (l *wl_library) wl_data_device_start_drag(wl_data_device *C.struct_wl_data_device, source *C.struct_wl_data_source, origin, icon *C.struct_wl_surface, serial C.uint32_t) {
	C.gamen_wl_data_device_start_drag(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_device, source, origin, icon, serial)
}

// copy data to the selection
//
// This request asks the compositor to set the selection
// to the data from the source on behalf of the client.
//
// To unset the selection, set the source to NULL.
func (l *wl_library) wl_data_device_set_selection(wl_data_device *C.struct_wl_data_device, source *C.struct_wl_data_source, serial C.uint32_t) {
	C.gamen_wl_data_device_set_selection(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_device, source, serial)
}

// destroy data device
//
// This request destroys the data device.
func (l *wl_library) wl_data_device_release(wl_data_device *C.struct_wl_data_device) {
	C.gamen_wl_data_device_release(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_device)
}

func (l *wl_library) wl_data_device_destroy(wl_data_device *C.struct_wl_data_device) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_data_device))
}

// This is a bitmask of the available/preferred actions in a
// drag-and-drop operation.
//
// In the compositor, the selected action is a result of matching the
// actions offered by the source and destination sides.  "action" events
// with a "none" action will be sent to both source and destination if
// there is no match. All further checks will effectively happen on
// (source actions âˆ© destination actions).
//
// In addition, compositors may also pick different actions in
// reaction to key modifiers being pressed. One common design that
// is used in major toolkits (and the behavior recommended for
// compositors) is:
//
// - If no modifiers are pressed, the first match (in bit order)
// will be used.
// - Pressing Shift selects "move", if enabled in the mask.
// - Pressing Control selects "copy", if enabled in the mask.
//
// Behavior beyond that is considered implementation-dependent.
// Compositors may for example bind other modifiers (like Alt/Meta)
// or drags initiated with other buttons than BTN_LEFT to specific
// actions (e.g. "ask").
type wl_data_device_manager_dnd_action C.uint32_t

const (
	// no action
	WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE wl_data_device_manager_dnd_action = 0
	// copy action
	WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY wl_data_device_manager_dnd_action = 1
	// move action
	WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE wl_data_device_manager_dnd_action = 2
	// ask action
	WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK wl_data_device_manager_dnd_action = 4
)

// create a new data source
//
// Create a new data source.
func (l *wl_library) wl_data_device_manager_create_data_source(wl_data_device_manager *C.struct_wl_data_device_manager) *C.struct_wl_data_source {
	return C.gamen_wl_data_device_manager_create_data_source(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_device_manager)
}

// create a new data device
//
// Create a new data device for a given seat.
func (l *wl_library) wl_data_device_manager_get_data_device(wl_data_device_manager *C.struct_wl_data_device_manager, seat *C.struct_wl_seat) *C.struct_wl_data_device {
	return C.gamen_wl_data_device_manager_get_data_device(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_data_device_manager, seat)
}

func (l *wl_library) wl_data_device_manager_destroy(wl_data_device_manager *C.struct_wl_data_device_manager) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_data_device_manager))
}

type wl_shell_error C.uint32_t

const (
	// given wl_surface has another role
	WL_SHELL_ERROR_ROLE wl_shell_error = 0
)

// create a shell surface from a surface
//
// Create a shell surface for an existing surface. This gives
// the wl_surface the role of a shell surface. If the wl_surface
// already has another role, it raises a protocol error.
//
// Only one shell surface can be associated with a given surface.
func (l *wl_library) wl_shell_get_shell_surface(wl_shell *C.struct_wl_shell, surface *C.struct_wl_surface) *C.struct_wl_shell_surface {
	return C.gamen_wl_shell_get_shell_surface(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell, surface)
}

func (l *wl_library) wl_shell_destroy(wl_shell *C.struct_wl_shell) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_shell))
}

// These values are used to indicate which edge of a surface
// is being dragged in a resize operation. The server may
// use this information to adapt its behavior, e.g. choose
// an appropriate cursor image.
type wl_shell_surface_resize C.uint32_t

const (
	// no edge
	WL_SHELL_SURFACE_RESIZE_NONE wl_shell_surface_resize = 0
	// top edge
	WL_SHELL_SURFACE_RESIZE_TOP wl_shell_surface_resize = 1
	// bottom edge
	WL_SHELL_SURFACE_RESIZE_BOTTOM wl_shell_surface_resize = 2
	// left edge
	WL_SHELL_SURFACE_RESIZE_LEFT wl_shell_surface_resize = 4
	// top and left edges
	WL_SHELL_SURFACE_RESIZE_TOP_LEFT wl_shell_surface_resize = 5
	// bottom and left edges
	WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT wl_shell_surface_resize = 6
	// right edge
	WL_SHELL_SURFACE_RESIZE_RIGHT wl_shell_surface_resize = 8
	// top and right edges
	WL_SHELL_SURFACE_RESIZE_TOP_RIGHT wl_shell_surface_resize = 9
	// bottom and right edges
	WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT wl_shell_surface_resize = 10
)

// These flags specify details of the expected behaviour
// of transient surfaces. Used in the set_transient request.
type wl_shell_surface_transient C.uint32_t

const (
	// do not set keyboard focus
	WL_SHELL_SURFACE_TRANSIENT_INACTIVE wl_shell_surface_transient = 0x1
)

// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type wl_shell_surface_fullscreen_method C.uint32_t

const (
	// no preference, apply default policy
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT wl_shell_surface_fullscreen_method = 0
	// scale, preserve the surface's aspect ratio and center on output
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE wl_shell_surface_fullscreen_method = 1
	// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER wl_shell_surface_fullscreen_method = 2
	// no upscaling, center on output and add black borders to compensate size mismatch
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL wl_shell_surface_fullscreen_method = 3
)

func (l *wl_library) wl_shell_surface_add_listener(wl_shell_surface *C.struct_wl_shell_surface, listener *C.struct_wl_shell_surface_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_shell_surface_add_listener(l.wl_proxy_add_listener_handle, wl_shell_surface, listener, data)
}

// respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive.
func (l *wl_library) wl_shell_surface_pong(wl_shell_surface *C.struct_wl_shell_surface, serial C.uint32_t) {
	C.gamen_wl_shell_surface_pong(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, serial)
}

// start an interactive move
//
// Start a pointer-driven move of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized).
func (l *wl_library) wl_shell_surface_move(wl_shell_surface *C.struct_wl_shell_surface, seat *C.struct_wl_seat, serial C.uint32_t) {
	C.gamen_wl_shell_surface_move(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, seat, serial)
}

// start an interactive resize
//
// Start a pointer-driven resizing of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
func (l *wl_library) wl_shell_surface_resize(wl_shell_surface *C.struct_wl_shell_surface, seat *C.struct_wl_seat, serial, edges C.uint32_t) {
	C.gamen_wl_shell_surface_resize(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, seat, serial, edges)
}

// make the surface a toplevel surface
//
// Map the surface as a toplevel surface.
//
// A toplevel surface is not fullscreen, maximized or transient.
func (l *wl_library) wl_shell_surface_set_toplevel(wl_shell_surface *C.struct_wl_shell_surface) {
	C.gamen_wl_shell_surface_set_toplevel(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface)
}

// make the surface a transient surface
//
// Map the surface relative to an existing surface.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
//
// The flags argument controls details of the transient behaviour.
func (l *wl_library) wl_shell_surface_set_transient(wl_shell_surface *C.struct_wl_shell_surface, parent *C.struct_wl_surface, x, y C.int32_t, flags C.uint32_t) {
	C.gamen_wl_shell_surface_set_transient(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, parent, x, y, flags)
}

// make the surface a fullscreen surface
//
// Map the surface as a fullscreen surface.
//
// If an output parameter is given then the surface will be made
// fullscreen on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The client may specify a method to resolve a size conflict
// between the output size and the surface size - this is provided
// through the method parameter.
//
// The framerate parameter is used only when the method is set
// to "driver", to indicate the preferred framerate. A value of 0
// indicates that the client does not care about framerate.  The
// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
//
// A method of "scale" or "driver" implies a scaling operation of
// the surface, either via a direct scaling operation or a change of
// the output mode. This will override any kind of output scaling, so
// that mapping a surface with a buffer size equal to the mode can
// fill the screen independent of buffer_scale.
//
// A method of "fill" means we don't scale up the buffer, however
// any output scale is applied. This means that you may run into
// an edge case where the application maps a buffer with the same
// size of the output mode but buffer_scale 1 (thus making a
// surface larger than the output). In this case it is allowed to
// downscale the results to fit the screen.
//
// The compositor must reply to this request with a configure event
// with the dimensions for the output on which the surface will
// be made fullscreen.
func (l *wl_library) wl_shell_surface_set_fullscreen(wl_shell_surface *C.struct_wl_shell_surface, method, framerate C.uint32_t, output *C.struct_wl_output) {
	C.gamen_wl_shell_surface_set_fullscreen(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, method, framerate, output)
}

// make the surface a popup surface
//
// Map the surface as a popup.
//
// A popup surface is a transient surface with an added pointer
// grab.
//
// An existing implicit grab will be changed to owner-events mode,
// and the popup grab will continue after the implicit grab ends
// (i.e. releasing the mouse button does not cause the popup to
// be unmapped).
//
// The popup grab continues until the window is destroyed or a
// mouse button is pressed in any other client's window. A click
// in any of the client's surfaces is reported as normal, however,
// clicks in other clients' surfaces will be discarded and trigger
// the callback.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
func (l *wl_library) wl_shell_surface_set_popup(wl_shell_surface *C.struct_wl_shell_surface, seat *C.struct_wl_seat, serial C.uint32_t, parent *C.struct_wl_surface, x, y C.int32_t, flags C.uint32_t) {
	C.gamen_wl_shell_surface_set_popup(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, seat, serial, parent, x, y, flags)
}

// make the surface a maximized surface
//
// Map the surface as a maximized surface.
//
// If an output parameter is given then the surface will be
// maximized on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The compositor will reply with a configure event telling
// the expected new surface size. The operation is completed
// on the next buffer attach to this surface.
//
// A maximized surface typically fills the entire output it is
// bound to, except for desktop elements such as panels. This is
// the main difference between a maximized shell surface and a
// fullscreen shell surface.
//
// The details depend on the compositor implementation.
func (l *wl_library) wl_shell_surface_set_maximized(wl_shell_surface *C.struct_wl_shell_surface, output *C.struct_wl_output) {
	C.gamen_wl_shell_surface_set_maximized(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, output)
}

// set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
func (l *wl_library) wl_shell_surface_set_title(wl_shell_surface *C.struct_wl_shell_surface, title *C.char) {
	C.gamen_wl_shell_surface_set_title(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, title)
}

// set surface class
//
// Set a class for the surface.
//
// The surface class identifies the general class of applications
// to which the surface belongs. A common convention is to use the
// file name (or the full path if it is a non-standard location) of
// the application's .desktop file as the class.
func (l *wl_library) wl_shell_surface_set_class(wl_shell_surface *C.struct_wl_shell_surface, class_ *C.char) {
	C.gamen_wl_shell_surface_set_class(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_shell_surface, class_)
}

func (l *wl_library) wl_shell_surface_destroy(wl_shell_surface *C.struct_wl_shell_surface) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_shell_surface))
}

// These errors can be emitted in response to wl_surface requests.
type wl_surface_error C.uint32_t

const (
	// buffer scale value is invalid
	WL_SURFACE_ERROR_INVALID_SCALE wl_surface_error = 0
	// buffer transform value is invalid
	WL_SURFACE_ERROR_INVALID_TRANSFORM wl_surface_error = 1
	// buffer size is invalid
	WL_SURFACE_ERROR_INVALID_SIZE wl_surface_error = 2
	// buffer offset is invalid
	WL_SURFACE_ERROR_INVALID_OFFSET wl_surface_error = 3
)

func (l *wl_library) wl_surface_add_listener(wl_surface *C.struct_wl_surface, listener *C.struct_wl_surface_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_surface_add_listener(l.wl_proxy_add_listener_handle, wl_surface, listener, data)
}

// delete surface
//
// Deletes the surface and invalidates its object ID.
func (l *wl_library) wl_surface_destroy(wl_surface *C.struct_wl_surface) {
	C.gamen_wl_surface_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface)
}

// set the surface contents
//
// Set a buffer as the content of this surface.
//
// The new size of the surface is calculated based on the buffer
// size transformed by the inverse buffer_transform and the
// inverse buffer_scale. This means that at commit time the supplied
// buffer size must be an integer multiple of the buffer_scale. If
// that's not the case, an invalid_size error is sent.
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes. Setting anything other than 0
// as x and y arguments is discouraged, and should instead be replaced
// with using the separate wl_surface.offset request.
//
// When the bound wl_surface version is 5 or higher, passing any
// non-zero x or y is a protocol violation, and will result in an
// 'invalid_offset' error being raised. To achieve equivalent semantics,
// use wl_surface.offset.
//
// Surface contents are double-buffered state, see wl_surface.commit.
//
// The initial surface contents are void; there is no content.
// wl_surface.attach assigns the given wl_buffer as the pending
// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
// surface contents, and the size of the surface becomes the size
// calculated from the wl_buffer, as described above. After commit,
// there is no pending buffer until the next attach.
//
// Committing a pending wl_buffer allows the compositor to read the
// pixels in the wl_buffer. The compositor may access the pixels at
// any time after the wl_surface.commit request. When the compositor
// will not access the pixels anymore, it will send the
// wl_buffer.release event. Only after receiving wl_buffer.release,
// the client may reuse the wl_buffer. A wl_buffer that has been
// attached and then replaced by another attach instead of committed
// will not receive a release event, and is not used by the
// compositor.
//
// If a pending wl_buffer has been committed to more than one wl_surface,
// the delivery of wl_buffer.release events becomes undefined. A well
// behaved client should not rely on wl_buffer.release events in this
// case. Alternatively, a client could create multiple wl_buffer objects
// from the same backing storage or use wp_linux_buffer_release.
//
// Destroying the wl_buffer after wl_buffer.release does not change
// the surface contents. Destroying the wl_buffer before wl_buffer.release
// is allowed as long as the underlying buffer storage isn't re-used (this
// can happen e.g. on client process termination). However, if the client
// destroys the wl_buffer before receiving the wl_buffer.release event and
// mutates the underlying buffer storage, the surface contents become
// undefined immediately.
//
// If wl_surface.attach is sent with a NULL wl_buffer, the
// following wl_surface.commit will remove the surface content.
func (l *wl_library) wl_surface_attach(wl_surface *C.struct_wl_surface, buffer *C.struct_wl_buffer, x, y C.int32_t) {
	C.gamen_wl_surface_attach(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, buffer, x, y)
}

// mark part of the surface damaged
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in surface-local coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage adds pending damage: the new pending damage
// is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// Note! New clients should not use this request. Instead damage can be
// posted with wl_surface.damage_buffer which uses buffer coordinates
// instead of surface coordinates.
func (l *wl_library) wl_surface_damage(wl_surface *C.struct_wl_surface, x, y, width, height C.int32_t) {
	C.gamen_wl_surface_damage(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, x, y, width, height)
}

// request a frame throttling hint
//
// Request a notification when it is a good time to start drawing a new
// frame, by creating a frame callback. This is useful for throttling
// redrawing operations, and driving animations.
//
// When a client is animating on a wl_surface, it can use the 'frame'
// request to get notified when it is a good time to draw and commit the
// next frame of animation. If the client commits an update earlier than
// that, it is likely that some updates will not make it to the display,
// and the client is wasting resources by drawing too often.
//
// The frame request will take effect on the next wl_surface.commit.
// The notification will only be posted for one frame unless
// requested again. For a wl_surface, the notifications are posted in
// the order the frame requests were committed.
//
// The server must send the notifications so that a client
// will not send excessive updates, while still allowing
// the highest possible update rate for clients that wait for the reply
// before drawing again. The server should give some time for the client
// to draw and commit after sending the frame callback events to let it
// hit the next output refresh.
//
// A server should avoid signaling the frame callbacks if the
// surface is not visible in any way, e.g. the surface is off-screen,
// or completely obscured by other opaque surfaces.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the current time, in
// milliseconds, with an undefined base.
func (l *wl_library) wl_surface_frame(wl_surface *C.struct_wl_surface) *C.struct_wl_callback {
	return C.gamen_wl_surface_frame(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface)
}

// set opaque region
//
// This request sets the region of the surface that contains
// opaque content.
//
// The opaque region is an optimization hint for the compositor
// that lets it optimize the redrawing of content behind opaque
// regions.  Setting an opaque region is not required for correct
// behaviour, but marking transparent content as opaque will result
// in repaint artifacts.
//
// The opaque region is specified in surface-local coordinates.
//
// The compositor ignores the parts of the opaque region that fall
// outside of the surface.
//
// Opaque region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_opaque_region changes the pending opaque region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise, the pending and current regions are never changed.
//
// The initial value for an opaque region is empty. Setting the pending
// opaque region has copy semantics, and the wl_region object can be
// destroyed immediately. A NULL wl_region causes the pending opaque
// region to be set to empty.
func (l *wl_library) wl_surface_set_opaque_region(wl_surface *C.struct_wl_surface, region *C.struct_wl_region) {
	C.gamen_wl_surface_set_opaque_region(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, region)
}

// set input region
//
// This request sets the region of the surface that can receive
// pointer and touch events.
//
// Input events happening outside of this region will try the next
// surface in the server surface stack. The compositor ignores the
// parts of the input region that fall outside of the surface.
//
// The input region is specified in surface-local coordinates.
//
// Input region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_input_region changes the pending input region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise the pending and current regions are never changed,
// except cursor and icon surfaces are special cases, see
// wl_pointer.set_cursor and wl_data_device.start_drag.
//
// The initial value for an input region is infinite. That means the
// whole surface will accept input. Setting the pending input region
// has copy semantics, and the wl_region object can be destroyed
// immediately. A NULL wl_region causes the input region to be set
// to infinite.
func (l *wl_library) wl_surface_set_input_region(wl_surface *C.struct_wl_surface, region *C.struct_wl_region) {
	C.gamen_wl_surface_set_input_region(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, region)
}

// commit pending surface state
//
// Surface state (input, opaque, and damage regions, attached buffers,
// etc.) is double-buffered. Protocol requests modify the pending state,
// as opposed to the current state in use by the compositor. A commit
// request atomically applies all pending state, replacing the current
// state. After commit, the new pending state is as documented for each
// related request.
//
// On commit, a pending wl_buffer is applied first, and all other state
// second. This means that all coordinates in double-buffered state are
// relative to the new wl_buffer coming into use, except for
// wl_surface.attach itself. If there is no pending wl_buffer, the
// coordinates are relative to the current surface contents.
//
// All requests that need a commit to become effective are documented
// to affect double-buffered state.
//
// Other interfaces may add further double-buffered surface state.
func (l *wl_library) wl_surface_commit(wl_surface *C.struct_wl_surface) {
	C.gamen_wl_surface_commit(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface)
}

// sets the buffer transformation
//
// This request sets an optional transformation on how the compositor
// interprets the contents of the buffer attached to the surface. The
// accepted values for the transform parameter are the values for
// wl_output.transform.
//
// Buffer transform is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer transformation set to normal.
//
// wl_surface.set_buffer_transform changes the pending buffer
// transformation. wl_surface.commit copies the pending buffer
// transformation to the current one. Otherwise, the pending and current
// values are never changed.
//
// The purpose of this request is to allow clients to render content
// according to the output transform, thus permitting the compositor to
// use certain optimizations even if the display is rotated. Using
// hardware overlays and scanning out a client buffer for fullscreen
// surfaces are examples of such optimizations. Those optimizations are
// highly dependent on the compositor implementation, so the use of this
// request should be considered on a case-by-case basis.
//
// Note that if the transform value includes 90 or 270 degree rotation,
// the width of the buffer will become the surface height and the height
// of the buffer will become the surface width.
//
// If transform is not one of the values from the
// wl_output.transform enum the invalid_transform protocol error
// is raised.
func (l *wl_library) wl_surface_set_buffer_transform(wl_surface *C.struct_wl_surface, transform C.int32_t) {
	C.gamen_wl_surface_set_buffer_transform(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, transform)
}

// sets the buffer scaling factor
//
// This request sets an optional scaling factor on how the compositor
// interprets the contents of the buffer attached to the window.
//
// Buffer scale is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer scale set to 1.
//
// wl_surface.set_buffer_scale changes the pending buffer scale.
// wl_surface.commit copies the pending buffer scale to the current one.
// Otherwise, the pending and current values are never changed.
//
// The purpose of this request is to allow clients to supply higher
// resolution buffer data for use on high resolution outputs. It is
// intended that you pick the same buffer scale as the scale of the
// output that the surface is displayed on. This means the compositor
// can avoid scaling when rendering the surface on that output.
//
// Note that if the scale is larger than 1, then you have to attach
// a buffer that is larger (by a factor of scale in each dimension)
// than the desired surface size.
//
// If scale is not positive the invalid_scale protocol error is
// raised.
func (l *wl_library) wl_surface_set_buffer_scale(wl_surface *C.struct_wl_surface, scale C.int32_t) {
	C.gamen_wl_surface_set_buffer_scale(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, scale)
}

// mark part of the surface damaged using buffer coordinates
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in buffer coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage_buffer adds pending damage: the new pending
// damage is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// This request differs from wl_surface.damage in only one way - it
// takes damage in buffer coordinates instead of surface-local
// coordinates. While this generally is more intuitive than surface
// coordinates, it is especially desirable when using wp_viewport
// or when a drawing library (like EGL) is unaware of buffer scale
// and buffer transform.
//
// Note: Because buffer transformation changes and damage requests may
// be interleaved in the protocol stream, it is impossible to determine
// the actual mapping between surface and buffer damage until
// wl_surface.commit time. Therefore, compositors wishing to take both
// kinds of damage into account will have to accumulate damage from the
// two requests separately and only transform from one to the other
// after receiving the wl_surface.commit.
func (l *wl_library) wl_surface_damage_buffer(wl_surface *C.struct_wl_surface, x, y, width, height C.int32_t) {
	C.gamen_wl_surface_damage_buffer(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, x, y, width, height)
}

// set the surface contents offset
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes.
//
// Surface location offset is double-buffered state, see
// wl_surface.commit.
//
// This request is semantically equivalent to and the replaces the x and y
// arguments in the wl_surface.attach request in wl_surface versions prior
// to 5. See wl_surface.attach for details.
func (l *wl_library) wl_surface_offset(wl_surface *C.struct_wl_surface, x, y C.int32_t) {
	C.gamen_wl_surface_offset(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_surface, x, y)
}

// This is a bitmask of capabilities this seat has; if a member is
// set, then it is present on the seat.
type wl_seat_capability C.uint32_t

const (
	// the seat has pointer devices
	WL_SEAT_CAPABILITY_POINTER wl_seat_capability = 1
	// the seat has one or more keyboards
	WL_SEAT_CAPABILITY_KEYBOARD wl_seat_capability = 2
	// the seat has touch devices
	WL_SEAT_CAPABILITY_TOUCH wl_seat_capability = 4
)

// These errors can be emitted in response to wl_seat requests.
type wl_seat_error C.uint32_t

const (
	// get_pointer, get_keyboard or get_touch called on seat without the matching capability
	WL_SEAT_ERROR_MISSING_CAPABILITY wl_seat_error = 0
)

func (l *wl_library) wl_seat_add_listener(wl_seat *C.struct_wl_seat, listener *C.struct_wl_seat_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_seat_add_listener(l.wl_proxy_add_listener_handle, wl_seat, listener, data)
}

// return pointer object
//
// The ID provided will be initialized to the wl_pointer interface
// for this seat.
//
// This request only takes effect if the seat has the pointer
// capability, or has had the pointer capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the pointer capability. The missing_capability error will
// be sent in this case.
func (l *wl_library) wl_seat_get_pointer(wl_seat *C.struct_wl_seat) *C.struct_wl_pointer {
	return C.gamen_wl_seat_get_pointer(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_seat)
}

// return keyboard object
//
// The ID provided will be initialized to the wl_keyboard interface
// for this seat.
//
// This request only takes effect if the seat has the keyboard
// capability, or has had the keyboard capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the keyboard capability. The missing_capability error will
// be sent in this case.
func (l *wl_library) wl_seat_get_keyboard(wl_seat *C.struct_wl_seat) *C.struct_wl_keyboard {
	return C.gamen_wl_seat_get_keyboard(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_seat)
}

// return touch object
//
// The ID provided will be initialized to the wl_touch interface
// for this seat.
//
// This request only takes effect if the seat has the touch
// capability, or has had the touch capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the touch capability. The missing_capability error will
// be sent in this case.
func (l *wl_library) wl_seat_get_touch(wl_seat *C.struct_wl_seat) *C.struct_wl_touch {
	return C.gamen_wl_seat_get_touch(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_seat)
}

// release the seat object
//
// Using this request a client can tell the server that it is not going to
// use the seat object anymore.
func (l *wl_library) wl_seat_release(wl_seat *C.struct_wl_seat) {
	C.gamen_wl_seat_release(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_seat)
}

func (l *wl_library) wl_seat_destroy(wl_seat *C.struct_wl_seat) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_seat))
}

type wl_pointer_error C.uint32_t

const (
	// given wl_surface has another role
	WL_POINTER_ERROR_ROLE wl_pointer_error = 0
)

// Describes the physical state of a button that produced the button
// event.
type wl_pointer_button_state C.uint32_t

const (
	// the button is not pressed
	WL_POINTER_BUTTON_STATE_RELEASED wl_pointer_button_state = 0
	// the button is pressed
	WL_POINTER_BUTTON_STATE_PRESSED wl_pointer_button_state = 1
)

// Describes the axis types of scroll events.
type wl_pointer_axis C.uint32_t

const (
	// vertical axis
	WL_POINTER_AXIS_VERTICAL_SCROLL wl_pointer_axis = 0
	// horizontal axis
	WL_POINTER_AXIS_HORIZONTAL_SCROLL wl_pointer_axis = 1
)

// Describes the source types for axis events. This indicates to the
// client how an axis event was physically generated; a client may
// adjust the user interface accordingly. For example, scroll events
// from a "finger" source may be in a smooth coordinate space with
// kinetic scrolling whereas a "wheel" source may be in discrete steps
// of a number of lines.
//
// The "continuous" axis source is a device generating events in a
// continuous coordinate space, but using something other than a
// finger. One example for this source is button-based scrolling where
// the vertical motion of a device is converted to scroll events while
// a button is held down.
//
// The "wheel tilt" axis source indicates that the actual device is a
// wheel but the scroll event is not caused by a rotation but a
// (usually sideways) tilt of the wheel.
type wl_pointer_axis_source C.uint32_t

const (
	// a physical wheel rotation
	WL_POINTER_AXIS_SOURCE_WHEEL wl_pointer_axis_source = 0
	// finger on a touch surface
	WL_POINTER_AXIS_SOURCE_FINGER wl_pointer_axis_source = 1
	// continuous coordinate space
	WL_POINTER_AXIS_SOURCE_CONTINUOUS wl_pointer_axis_source = 2
	// a physical wheel tilt
	WL_POINTER_AXIS_SOURCE_WHEEL_TILT wl_pointer_axis_source = 3
)

func (l *wl_library) wl_pointer_add_listener(wl_pointer *C.struct_wl_pointer, listener *C.struct_wl_pointer_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_pointer_add_listener(l.wl_proxy_add_listener_handle, wl_pointer, listener, data)
}

// set the pointer surface
//
// Set the pointer surface, i.e., the surface that contains the
// pointer image (cursor). This request gives the surface the role
// of a cursor. If the surface already has another role, it raises
// a protocol error.
//
// The cursor actually changes only if the pointer
// focus for this device is one of the requesting client's surfaces
// or the surface parameter is the current pointer surface. If
// there was a previous surface set with this request it is
// replaced. If surface is NULL, the pointer image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of
// the pointer surface relative to the pointer location. Its
// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
// where (x, y) are the coordinates of the pointer location, in
// surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x
// and hotspot_y are decremented by the x and y parameters
// passed to the request. Attach must be confirmed by
// wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set
// pointer surface to this request with new values for hotspot_x
// and hotspot_y.
//
// The current and pending input regions of the wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the cursor. When the use as a
// cursor ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
//
// The serial parameter must match the latest wl_pointer.enter
// serial number sent to the client. Otherwise the request will be
// ignored.
func (l *wl_library) wl_pointer_set_cursor(wl_pointer *C.struct_wl_pointer, serial C.uint32_t, surface *C.struct_wl_surface, hotspot_x, hotspot_y C.int32_t) {
	C.gamen_wl_pointer_set_cursor(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_pointer, serial, surface, hotspot_x, hotspot_y)
}

// release the pointer object
//
// Using this request a client can tell the server that it is not going to
// use the pointer object anymore.
//
// This request destroys the pointer proxy object, so clients must not call
// wl_pointer_destroy() after using this request.
func (l *wl_library) wl_pointer_release(wl_pointer *C.struct_wl_pointer) {
	C.gamen_wl_pointer_release(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_pointer)
}

func (l *wl_library) wl_pointer_destroy(wl_pointer *C.struct_wl_pointer) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_pointer))
}

// This specifies the format of the keymap provided to the
// client with the wl_keyboard.keymap event.
type wl_keyboard_keymap_format C.uint32_t

const (
	// no keymap; client must understand how to interpret the raw keycode
	WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP wl_keyboard_keymap_format = 0
	// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
	WL_KEYBOARD_KEYMAP_FORMAT_XKB_V_1 wl_keyboard_keymap_format = 1
)

// Describes the physical state of a key that produced the key event.
type wl_keyboard_key_state C.uint32_t

const (
	// key is not pressed
	WL_KEYBOARD_KEY_STATE_RELEASED wl_keyboard_key_state = 0
	// key is pressed
	WL_KEYBOARD_KEY_STATE_PRESSED wl_keyboard_key_state = 1
)

func (l *wl_library) wl_keyboard_add_listener(wl_keyboard *C.struct_wl_keyboard, listener *C.struct_wl_keyboard_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_keyboard_add_listener(l.wl_proxy_add_listener_handle, wl_keyboard, listener, data)
}

// release the keyboard object
func (l *wl_library) wl_keyboard_release(wl_keyboard *C.struct_wl_keyboard) {
	C.gamen_wl_keyboard_release(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_keyboard)
}

func (l *wl_library) wl_keyboard_destroy(wl_keyboard *C.struct_wl_keyboard) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_keyboard))
}

func (l *wl_library) wl_touch_add_listener(wl_touch *C.struct_wl_touch, listener *C.struct_wl_touch_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_touch_add_listener(l.wl_proxy_add_listener_handle, wl_touch, listener, data)
}

// release the touch object
func (l *wl_library) wl_touch_release(wl_touch *C.struct_wl_touch) {
	C.gamen_wl_touch_release(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_touch)
}

func (l *wl_library) wl_touch_destroy(wl_touch *C.struct_wl_touch) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_touch))
}

// This enumeration describes how the physical
// pixels on an output are laid out.
type wl_output_subpixel C.uint32_t

const (
	// unknown geometry
	WL_OUTPUT_SUBPIXEL_UNKNOWN wl_output_subpixel = 0
	// no geometry
	WL_OUTPUT_SUBPIXEL_NONE wl_output_subpixel = 1
	// horizontal RGB
	WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB wl_output_subpixel = 2
	// horizontal BGR
	WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR wl_output_subpixel = 3
	// vertical RGB
	WL_OUTPUT_SUBPIXEL_VERTICAL_RGB wl_output_subpixel = 4
	// vertical BGR
	WL_OUTPUT_SUBPIXEL_VERTICAL_BGR wl_output_subpixel = 5
)

// This describes the transform that a compositor will apply to a
// surface to compensate for the rotation or mirroring of an
// output device.
//
// The flipped values correspond to an initial flip around a
// vertical axis followed by rotation.
//
// The purpose is mainly to allow clients to render accordingly and
// tell the compositor, so that for fullscreen surfaces, the
// compositor will still be able to scan out directly from client
// surfaces.
type wl_output_transform C.uint32_t

const (
	// no transform
	WL_OUTPUT_TRANSFORM_NORMAL wl_output_transform = 0
	// 90 degrees counter-clockwise
	WL_OUTPUT_TRANSFORM_90 wl_output_transform = 1
	// 180 degrees counter-clockwise
	WL_OUTPUT_TRANSFORM_180 wl_output_transform = 2
	// 270 degrees counter-clockwise
	WL_OUTPUT_TRANSFORM_270 wl_output_transform = 3
	// 180 degree flip around a vertical axis
	WL_OUTPUT_TRANSFORM_FLIPPED wl_output_transform = 4
	// flip and rotate 90 degrees counter-clockwise
	WL_OUTPUT_TRANSFORM_FLIPPED_90 wl_output_transform = 5
	// flip and rotate 180 degrees counter-clockwise
	WL_OUTPUT_TRANSFORM_FLIPPED_180 wl_output_transform = 6
	// flip and rotate 270 degrees counter-clockwise
	WL_OUTPUT_TRANSFORM_FLIPPED_270 wl_output_transform = 7
)

// These flags describe properties of an output mode.
// They are used in the flags bitfield of the mode event.
type wl_output_mode C.uint32_t

const (
	// indicates this is the current mode
	WL_OUTPUT_MODE_CURRENT wl_output_mode = 0x1
	// indicates this is the preferred mode
	WL_OUTPUT_MODE_PREFERRED wl_output_mode = 0x2
)

func (l *wl_library) wl_output_add_listener(wl_output *C.struct_wl_output, listener *C.struct_wl_output_listener, data unsafe.Pointer) C.int {
	return C.gamen_wl_output_add_listener(l.wl_proxy_add_listener_handle, wl_output, listener, data)
}

// release the output object
//
// Using this request a client can tell the server that it is not going to
// use the output object anymore.
func (l *wl_library) wl_output_release(wl_output *C.struct_wl_output) {
	C.gamen_wl_output_release(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_output)
}

func (l *wl_library) wl_output_destroy(wl_output *C.struct_wl_output) {
	l.wl_proxy_destroy((*C.struct_wl_proxy)(wl_output))
}

// destroy region
//
// Destroy the region.  This will invalidate the object ID.
func (l *wl_library) wl_region_destroy(wl_region *C.struct_wl_region) {
	C.gamen_wl_region_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_region)
}

// add rectangle to region
//
// Add the specified rectangle to the region.
func (l *wl_library) wl_region_add(wl_region *C.struct_wl_region, x, y, width, height C.int32_t) {
	C.gamen_wl_region_add(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_region, x, y, width, height)
}

// subtract rectangle from region
//
// Subtract the specified rectangle from the region.
func (l *wl_library) wl_region_subtract(wl_region *C.struct_wl_region, x, y, width, height C.int32_t) {
	C.gamen_wl_region_subtract(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_region, x, y, width, height)
}

type wl_subcompositor_error C.uint32_t

const (
	// the to-be sub-surface is invalid
	WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE wl_subcompositor_error = 0
)

// unbind from the subcompositor interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other
// objects, wl_subsurface objects included.
func (l *wl_library) wl_subcompositor_destroy(wl_subcompositor *C.struct_wl_subcompositor) {
	C.gamen_wl_subcompositor_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subcompositor)
}

// give a surface the role sub-surface
//
// Create a sub-surface interface for the given surface, and
// associate it with the given parent surface. This turns a
// plain wl_surface into a sub-surface.
//
// The to-be sub-surface must not already have another role, and it
// must not have an existing wl_subsurface object. Otherwise a protocol
// error is raised.
//
// Adding sub-surfaces to a parent is a double-buffered operation on the
// parent (see wl_surface.commit). The effect of adding a sub-surface
// becomes visible on the next time the state of the parent surface is
// applied.
//
// This request modifies the behaviour of wl_surface.commit request on
// the sub-surface, see the documentation on wl_subsurface interface.
func (l *wl_library) wl_subcompositor_get_subsurface(wl_subcompositor *C.struct_wl_subcompositor, surface, parent *C.struct_wl_surface) *C.struct_wl_subsurface {
	return C.gamen_wl_subcompositor_get_subsurface(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subcompositor, surface, parent)
}

type wl_subsurface_error C.uint32_t

const (
	// wl_surface is not a sibling or the parent
	WL_SUBSURFACE_ERROR_BAD_SURFACE wl_subsurface_error = 0
)

// remove sub-surface interface
//
// The sub-surface interface is removed from the wl_surface object
// that was turned into a sub-surface with a
// wl_subcompositor.get_subsurface request. The wl_surface's association
// to the parent is deleted, and the wl_surface loses its role as
// a sub-surface. The wl_surface is unmapped immediately.
func (l *wl_library) wl_subsurface_destroy(wl_subsurface *C.struct_wl_subsurface) {
	C.gamen_wl_subsurface_destroy(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subsurface)
}

// reposition the sub-surface
//
// This schedules a sub-surface position change.
// The sub-surface will be moved so that its origin (top left
// corner pixel) will be at the location x, y of the parent surface
// coordinate system. The coordinates are not restricted to the parent
// surface area. Negative values are allowed.
//
// The scheduled coordinates will take effect whenever the state of the
// parent surface is applied. When this happens depends on whether the
// parent surface is in synchronized mode or not. See
// wl_subsurface.set_sync and wl_subsurface.set_desync for details.
//
// If more than one set_position request is invoked by the client before
// the commit of the parent surface, the position of a new request always
// replaces the scheduled position from any previous request.
//
// The initial position is 0, 0.
func (l *wl_library) wl_subsurface_set_position(wl_subsurface *C.struct_wl_subsurface, x, y C.int32_t) {
	C.gamen_wl_subsurface_set_position(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subsurface, x, y)
}

// restack the sub-surface
//
// This sub-surface is taken from the stack, and put back just
// above the reference surface, changing the z-order of the sub-surfaces.
// The reference surface must be one of the sibling surfaces, or the
// parent surface. Using any other surface, including this sub-surface,
// will cause a protocol error.
//
// The z-order is double-buffered. Requests are handled in order and
// applied immediately to a pending state. The final pending state is
// copied to the active state the next time the state of the parent
// surface is applied. When this happens depends on whether the parent
// surface is in synchronized mode or not. See wl_subsurface.set_sync and
// wl_subsurface.set_desync for details.
//
// A new sub-surface is initially added as the top-most in the stack
// of its siblings and parent.
func (l *wl_library) wl_subsurface_place_above(wl_subsurface *C.struct_wl_subsurface, sibling *C.struct_wl_surface) {
	C.gamen_wl_subsurface_place_above(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subsurface, sibling)
}

// restack the sub-surface
//
// The sub-surface is placed just below the reference surface.
// See wl_subsurface.place_above.
func (l *wl_library) wl_subsurface_place_below(wl_subsurface *C.struct_wl_subsurface, sibling *C.struct_wl_surface) {
	C.gamen_wl_subsurface_place_below(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subsurface, sibling)
}

// set sub-surface to synchronized mode
//
// Change the commit behaviour of the sub-surface to synchronized
// mode, also described as the parent dependent mode.
//
// In synchronized mode, wl_surface.commit on a sub-surface will
// accumulate the committed state in a cache, but the state will
// not be applied and hence will not change the compositor output.
// The cached state is applied to the sub-surface immediately after
// the parent surface's state is applied. This ensures atomic
// updates of the parent and all its synchronized sub-surfaces.
// Applying the cached state will invalidate the cache, so further
// parent surface commits do not (re-)apply old state.
//
// See wl_subsurface for the recursive effect of this mode.
func (l *wl_library) wl_subsurface_set_sync(wl_subsurface *C.struct_wl_subsurface) {
	C.gamen_wl_subsurface_set_sync(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subsurface)
}

// set sub-surface to desynchronized mode
//
// Change the commit behaviour of the sub-surface to desynchronized
// mode, also described as independent or freely running mode.
//
// In desynchronized mode, wl_surface.commit on a sub-surface will
// apply the pending state directly, without caching, as happens
// normally with a wl_surface. Calling wl_surface.commit on the
// parent surface has no effect on the sub-surface's wl_surface
// state. This mode allows a sub-surface to be updated on its own.
//
// If cached state exists when wl_surface.commit is called in
// desynchronized mode, the pending state is added to the cached
// state, and applied as a whole. This invalidates the cache.
//
// Note: even if a sub-surface is set to desynchronized, a parent
// sub-surface may override it to behave as synchronized. For details,
// see wl_subsurface.
//
// If a surface's parent surface behaves as desynchronized, then
// the cached state is applied on set_desync.
func (l *wl_library) wl_subsurface_set_desync(wl_subsurface *C.struct_wl_subsurface) {
	C.gamen_wl_subsurface_set_desync(l.wl_proxy_marshal_flags, l.wl_proxy_get_version, wl_subsurface)
}
